package 大厂刷题;

/**
 * @author Chu
 * @create 2022-02-16  14:03
 */
/*
* 一个子序列(不连续)的消除规则如下：
*   1）在某一个子序列中，如果'1'的左边有'0'，那么这两个字符->"01"可以消除
*   2）在某一个子序列中，如果'3'的左边有'2'，那么这两个字符->"23"可以消除
*   3）当这个子序列的某个部分消除之后，认为其他字符会自动贴在一起，可以继续寻找消除的机会
* 比如，某个子序列"0231"，先消除"23"，剩下消除"01",没有字符了
* 如果某个子序列通过最优良的方式，可以都消掉，那么这样的子序列叫做"全消子序列"
* 一个只由'0'、'1'、'2'、'3'四种字符组成的字符串str，可以生成很多子序列，返回"全校子序列"的最大长度
* 字符串str长度 <= 200
* */
public class Q59_全消子序列的最大长度 {

    public static int maxDisappear(String str){
        if (str == null || str.length() == 0){
            return 0;
        }
        return disappear(str.toCharArray(),0,str.length() - 1);
    }

    // s[l..r]范围上，如题目所说的方式，最长的都能消掉的子序列长度
    public static int disappear(char[] s,int l, int r){
        if(l >= r){        // 剩一个或不是有效范围
            return 0;
        }
        if(l == r - 1){    // 剩两个
            return (s[l] == '0' && s[r] == '1') || (s[l] == '2' && s[r] == '3') ? 2 : 0;
        }
        // l..r 有若干个字符
        // 可能性1：能消掉的子序列完全不考虑s[l],最长是多少
        int p1 = disappear(s, l + 1,r);
        if (s[l] == '1' || s[l] == '3'){    // 如果此位置字符是1/3,那只有一种可能
            return p1;
        }

        // s[l] == '0' 或者 '2'
        // 说明可以有可能性2：能消掉的子序列必须考虑s[l],最长是多少
        // '0' 去找 '1'  '2' 去找 '3'
        char find = s[l] == '0' ? '1' : '3';

        int p2 = 0;
        // l() ...
        for (int i = l + 1;i <= r;i++){
            // l(0) ... i(1)  i+1...r       假如在l处为0，i位置为1(后面可能还有1，因此for循环枚举全部的可能，取最大)
            if (s[i] == find){      // l+1..i-1中间消去的长度+2(2个数) + 后面字符的最大消去长度
                p2 = Math.max(p2, disappear(s,l+1,i-1) + 2 + disappear(s,i+1,r));
            }
        }

        return Math.max(p1,p2);
    }

}
